#include <iostream>
#include <fstream>
#include <vector>
const int MaxN = 9; // Максимальное количество строк или столбцов (из условия: 1 ≤ M, N ≤ 9)
const int MaxP = 48620; // Максимальное количество возможных позиций (C_18^9)

using namespace std;

using Diagr = vector<int>; // Определяем тип Diagr как вектор целых чисел для представления позиции пирога

/// <summary>
/// Вычисление комбинаторной таблицы C
/// </summary>
/// <param name="C - таблица комбинаций"></param>
void calcA(vector<vector<int>>& C) 
{ 
    for (int l = 0; l <= MaxN; l++) // Для всех возможных значений l (0..9)
    {
        C[0][l] = 1; // База: для 0 строк любое l дает 1 вариант
    }
    for (int k = 1; k <= MaxN; k++) // Для каждой строки k (1..9)
    {
        C[k][0] = 0; // Если l = -1 (смещено в 0), вариантов нет
        C[k][1] = 1; // Если l = 0, только одна комбинация (все 0)
        for (int l = 1; l <= MaxN; l++) // Для l от 0 до MaxN (смещено: 1..10)
        {
            C[k][l + 1] = C[k][l] + C[k - 1][l + 1]; // Рекуррентная формула
        }
    }
}

/// <summary>
/// Преобразование числа в позицию (декодирование)
/// </summary>
/// <param name="n - колво столбцов"></param>
/// <param name="P - вектор позиции"></param>
/// <param name="C - табоица комбинаций"></param>
/// <param name="M - колво строк"></param>
void num2pos(int n, Diagr& P, const vector<vector<int>>& C, const int M) 
{
    P.resize(M + 1); // Устанавливаем размер вектора P под M строк (+1 для индексации с 1)
    for (int i = 1; i <= M; i++) // Для каждой строки
    {
        int j = 0; // j - количество клеток в текущей строке
        while (j <= MaxN && n >= C[M - i + 1][j + 1]) // Пока j в пределах и n достаточно большой
        {
            j++; // Увеличиваем j
        }
        P[i] = j; // Записываем найденное значение в позицию
        n = n - C[M - i + 1][j]; // Вычитаем использованную часть числа
    }
}

/// <summary>
/// Преобразование позиции в число (кодирование)
/// </summary>
/// <param name="P - вектор позиции"></param>
/// <param name="C - таблиц комбинаций"></param>
/// <param name="M - количество строк"></param>
/// <returns></returns>
int pos2num(const Diagr& P, const vector<vector<int>>& C, const int M) 
{
    int n = 0; // Инициализируем результат
    for (int i = 1; i <= M; i++) // Для каждой строки
    {
        n += C[M - i + 1][P[i]]; // Добавляем комбинаторное значение для текущего числа клеток
    }
    return n; // Возвращаем закодированное число
}

/// <summary>
/// Вычисление выигрышности позиции
/// </summary>
/// <param name="P - числовое представление позиции"></param>
/// <param name="M - количество строк"></param>
/// <param name="C - таблица комбинаций"></param>
/// <param name="W - массив выйгрышности"></param>
/// <returns>
/// выигрышная позиция или нет
/// </returns>
bool calcW(const int P, const int M, const vector<vector<int>> &C, vector<bool> &W) 
{
    Diagr TP(M + 1), NP(M + 1); // TP - текущая позиция, NP - следующая позиция после хода
    num2pos(P, TP, C, M); // Декодируем P в TP
    for (int i = 1; i <= M; i++) // Для каждой строки
    {
        for (int j = 0; j < TP[i]; j++) // Для каждого возможного столбца до текущего значения
        {
            NP = TP; // Копируем текущую позицию
            for (int k = i; k <= M; k++) // Обрезаем все строки от i и выше
            {
                if (NP[k] > j) // Если в строке больше клеток, чем j
                {
                    NP[k] = j; // Устанавливаем новое значение (съедаем до j)
                }
            }
            if (!W[pos2num(NP, C, M)]) // Если новая позиция проигрышная для следующего игрока 
            {
                return true; // Текущая позиция выигрышная
            }
        }
    }
    return false; // Если все ходы ведут к выигрышу противника, позиция проигрышная
}

/// <summary>
/// Вывод ответа
/// </summary>
/// <param name="M - количество строк"></param>
/// <param name="VXD - числовое представление текущей позиции"></param>
/// <param name="W - массив выигрышности"></param>
/// <param name="C - таблица комбинаций"></param>
void writeAnswer(const int M, const int VXD,const vector<bool> &W, const vector<vector<int>> &C) 
{
    Diagr TP(M + 1), NP(M + 1); // TP - текущая позиция, NP - позиция после хода
    vector<pair<int, int>> res; // Вектор для хранения выигрышных ходов

    num2pos(VXD, TP, C, M); // Декодируем начальную позицию
    for (int i = 1; i <= M; i++) // Для каждой строки
    {
        for (int j = 0; j < TP[i]; j++) // Для каждого столбца до текущего значения
        {
            NP = TP; // Копируем текущую позицию
            for (int k = i; k <= M; k++) // Обрезаем строки от i и выше
            {
                if (NP[k] > j) // Если в строке больше клеток
                {
                    NP[k] = j;   // Съедаем до j
                }
            }
            if (!W[pos2num(NP, C, M)]) { // Если ход ведет к проигрышной позиции для противника
                res.push_back({ i, j + 1 }); // Добавляем ход (i, j+1) в результат
            }
        }
    }

    cout << res.size() << endl; // Выводим количество выигрышных ходов
    for (const auto& move : res) { // Для каждого выигрышного хода
        cout << move.first << " " << move.second << endl; // Выводим координаты (строка, столбец)
    }
}

int main() {

    int N, M; // N - количество столбцов, M - количество строк
    Diagr X; // Вектор X хранит текущую позицию (число оставшихся клеток в каждой строке)
    int VXD; // Числовое представление текущей позиции
    vector<vector<int>> C(MaxN + 1, vector<int>(MaxN + 2, 0)); // Таблица комбинаций: C[k][l] - число позиций с k строками, где все <= l
    vector<bool> W(MaxP, false); // Массив выигрышности: W[i] = true, если позиция i выигрышная для следующего игрока

    ifstream fin("input.txt"); // Открываем файл input.txt для чтения
    if (!fin.is_open())  // Проверяем, удалось ли открыть файл
    {
        cerr << "Невозможно отркрыть input.txt" << endl;
        return 1; // Выходим с ошибкой, если файл не открыт
    }

    fin >> M >> N; // Читаем M (строки) и N (столбцы)
    X.resize(M + 1); // Устанавливаем размер вектора X под M строк
    for (int i = 1; i <= M; i++) // Читаем количество клеток для каждой строки
    {
        fin >> X[i];
    }
    fin.close(); // Закрываем входной файл

    calcA(C); // Вычисляем комбинаторную таблицу
    VXD = pos2num(X, C, M); // Кодируем начальную позицию в число
    W[0] = true; // Пустая позиция (0) - выигрышная для следующего игрока

    for (int i = 1; i <= VXD; i++) // Для всех позиций до текущей
    {
        W[i] = calcW(i, M, C, W); // Определяем, выигрышная ли позиция
    }

    ofstream fout("output.txt"); // Открываем файл output.txt для записи
    if (!fout.is_open()) // Проверяем, удалось ли открыть файл
    {
        cerr << "Невозможно открыть output.txt" << endl;
        return 1; // Выходим с ошибкой, если файл не открыт
    }

    streambuf* coutbuf = cout.rdbuf(); // Сохраняем стандартный буфер вывода
    cout.rdbuf(fout.rdbuf()); // Перенаправляем вывод в файл

    writeAnswer(M, VXD, W, C); // Выводим ответ в файл

    cout.rdbuf(coutbuf); // Восстанавливаем стандартный вывод
    fout.close(); // Закрываем выходной файл

    return 0; // Успешное завершение программы
}
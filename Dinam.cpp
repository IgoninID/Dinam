#include <iostream> // Подключаем библиотеку для ввода-вывода
#include <fstream>  // Подключаем библиотеку для работы с файлами
#include <vector>   // Подключаем библиотеку для работы с векторами

using namespace std;

const int MaxN = 9;      // Максимальное количество строк или столбцов (из условия: 1 ≤ M, N ≤ 9)
const int MaxP = 48620;  // Максимальное количество возможных позиций (C_18^9, заранее вычисленная константа)

using Diagr = vector<int>; // Определяем тип Diagr как вектор целых чисел для представления позиции пирога

// Глобальные переменные
int N, M;                  // N - количество столбцов, M - количество строк
Diagr X;                   // Вектор X хранит текущую позицию (число оставшихся клеток в каждой строке)
int VXD;                   // Числовое представление текущей позиции
vector<vector<int>> C(MaxN + 1, vector<int>(MaxN + 2, 0)); // Таблица комбинаций: C[k][l] - число позиций с k строками, где все <= l
vector<bool> W(MaxP, false); // Массив выигрышности: W[i] = true, если позиция i выигрышная для следующего игрока

/// Вычисление комбинаторной таблицы C
void calcA() {
    for (int l = 0; l <= MaxN; l++) { // Для всех возможных значений l (0..9)
        C[0][l] = 1;                  // База: для 0 строк любое l дает 1 вариант
    }
    for (int k = 1; k <= MaxN; k++) { // Для каждой строки k (1..9)
        C[k][0] = 0;                  // Если l = -1 (смещено в 0), вариантов нет
        C[k][1] = 1;                  // Если l = 0, только одна комбинация (все 0)
        for (int l = 1; l <= MaxN; l++) { // Для l от 0 до MaxN (смещено: 1..10)
            C[k][l + 1] = C[k][l] + C[k - 1][l + 1]; // Рекуррентная формула: C[k,l] = C[k,l-1] + C[k-1,l]
        }
    }
}

/// Преобразование числа в позицию (декодирование)
void num2pos(int n, Diagr& P) { // n - число, P - вектор позиции
    P.resize(M + 1);            // Устанавливаем размер вектора P под M строк (+1 для индексации с 1)
    for (int i = 1; i <= M; i++) { // Для каждой строки
        int j = 0;              // j - количество клеток в текущей строке
        while (j <= MaxN && n >= C[M - i + 1][j + 1]) { // Пока j в пределах и n достаточно большой
            j++;                // Увеличиваем j
        }
        P[i] = j;               // Записываем найденное значение в позицию
        n = n - C[M - i + 1][j]; // Вычитаем использованную часть числа
    }
}

/// Преобразование позиции в число (кодирование)
int pos2num(const Diagr& P) { // P - вектор позиции
    int n = 0;                // Инициализируем результат
    for (int i = 1; i <= M; i++) { // Для каждой строки
        n += C[M - i + 1][P[i]];   // Добавляем комбинаторное значение для текущего числа клеток
    }
    return n;                 // Возвращаем закодированное число
}

/// Вычисление выигрышности позиции
bool calcW(int P) {           // P - числовое представление позиции
    Diagr TP(M + 1), NP(M + 1); // TP - текущая позиция, NP - следующая позиция после хода
    num2pos(P, TP);          // Декодируем P в TP
    for (int i = 1; i <= M; i++) { // Для каждой строки
        for (int j = 0; j < TP[i]; j++) { // Для каждого возможного столбца до текущего значения
            NP = TP;          // Копируем текущую позицию
            for (int k = i; k <= M; k++) { // Обрезаем все строки от i и выше
                if (NP[k] > j) { // Если в строке больше клеток, чем j
                    NP[k] = j;   // Устанавливаем новое значение (съедаем до j)
                }
            }
            if (!W[pos2num(NP)]) { // Если новая позиция проигрышная для следующего игрока
                return true;   // Текущая позиция выигрышная
            }
        }
    }
    return false;             // Если все ходы ведут к выигрышу противника, позиция проигрышная
}

/// Вывод ответа
void writeAnswer() {
    Diagr TP(M + 1), NP(M + 1); // TP - текущая позиция, NP - позиция после хода
    vector<pair<int, int>> res; // Вектор для хранения выигрышных ходов

    num2pos(VXD, TP);        // Декодируем начальную позицию
    for (int i = 1; i <= M; i++) { // Для каждой строки
        for (int j = 0; j < TP[i]; j++) { // Для каждого столбца до текущего значения
            NP = TP;          // Копируем текущую позицию
            for (int k = i; k <= M; k++) { // Обрезаем строки от i и выше
                if (NP[k] > j) { // Если в строке больше клеток
                    NP[k] = j;   // Съедаем до j
                }
            }
            if (!W[pos2num(NP)]) { // Если ход ведет к проигрышной позиции для противника
                res.push_back({ i, j + 1 }); // Добавляем ход (i, j+1) в результат
            }
        }
    }

    cout << res.size() << endl; // Выводим количество выигрышных ходов
    for (const auto& move : res) { // Для каждого выигрышного хода
        cout << move.first << " " << move.second << endl; // Выводим координаты (строка, столбец)
    }
}

int main() {
    ifstream fin("input.txt"); // Открываем файл input.txt для чтения
    if (!fin.is_open()) {      // Проверяем, удалось ли открыть файл
        cerr << "Cannot open input.txt" << endl;
        return 1;              // Выходим с ошибкой, если файл не открыт
    }

    fin >> M >> N;             // Читаем M (строки) и N (столбцы)
    X.resize(M + 1);           // Устанавливаем размер вектора X под M строк
    for (int i = 1; i <= M; i++) { // Читаем количество клеток для каждой строки
        fin >> X[i];
    }
    fin.close();               // Закрываем входной файл

    calcA();                   // Вычисляем комбинаторную таблицу
    VXD = pos2num(X);          // Кодируем начальную позицию в число
    W[0] = true;               // Пустая позиция (0) - выигрышная для следующего игрока

    for (int i = 1; i <= VXD; i++) { // Для всех позиций до текущей
        W[i] = calcW(i);       // Определяем, выигрышная ли позиция
    }

    ofstream fout("output.txt"); // Открываем файл output.txt для записи
    if (!fout.is_open()) {     // Проверяем, удалось ли открыть файл
        cerr << "Cannot open output.txt" << endl;
        return 1;              // Выходим с ошибкой, если файл не открыт
    }

    streambuf* coutbuf = cout.rdbuf(); // Сохраняем стандартный буфер вывода
    cout.rdbuf(fout.rdbuf());  // Перенаправляем вывод в файл

    writeAnswer();             // Выводим ответ в файл

    cout.rdbuf(coutbuf);       // Восстанавливаем стандартный вывод
    fout.close();              // Закрываем выходной файл

    return 0;                  // Успешное завершение программы
}